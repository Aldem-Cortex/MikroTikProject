/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string>
#include <regex>
#include <vector>
#include "main.h"
#include "init.h"
#include "interrupts.h"
#include "defines.h"

using namespace std;
extern string ReceiveBuffer;

void LED_1_ON( uint16_t time )
{
	RCC->APBRSTR1 |= RCC_APBRSTR1_TIM3RST;
	RCC->APBRSTR1 &= ~RCC_APBRSTR1_TIM3RST;
	TIM3->PSC = 12000000 / 1000;
	TIM3->ARR = time;
	TIM3->EGR |= TIM_EGR_UG;
	TIM3->CR1 |= TIM_CR1_CEN;

	switch( LED_1_PIN ) // set LED_1_PIN as output
	{
	case 4:
		GPIOA->ODR |= GPIO_ODR_OD4;
		break;
	case 5:
		GPIOA->ODR |= GPIO_ODR_OD5;
		break;
	case 6:
		GPIOA->ODR |= GPIO_ODR_OD6;
		break;
	case 7:
		GPIOA->ODR |= GPIO_ODR_OD7;
		break;
	default:
		break;
	}
}

void LED_2_ON( uint8_t time )
{
	RCC->APBRSTR2 |= RCC_APBRSTR2_TIM14RST;
	RCC->APBRSTR2 &= ~RCC_APBRSTR2_TIM14RST;
	TIM14->PSC = 12000000 / 1000;
	TIM14->ARR = time;
	TIM14->EGR |= TIM_EGR_UG;
	TIM14->CR1 |= TIM_CR1_CEN;

	switch( LED_2_PIN ) // activate LED_2_PIN output
	{
	case 4:
		GPIOA->ODR |= GPIO_ODR_OD4;
		break;
	case 5:
		GPIOA->ODR |= GPIO_ODR_OD5;
		break;
	case 6:
		GPIOA->ODR |= GPIO_ODR_OD6;
		break;
	case 7:
		GPIOA->ODR |= GPIO_ODR_OD7;
		break;
	default:
		break;
	}
}

void SendMessage( string data, uint8_t length )
{
	uint8_t counter = 0;
	while( counter++ < length )
	{
		while( !( USART1->ISR & USART_ISR_TXFE ) ) {};
		USART1->TDR = data.at( counter );
	}
}

int main(void)
{
	InitUSART1();
	InitGPIO();
	InitTimers();
    /* Loop forever */
	for(;;)
	{
		if( recFlg.ReceiveFinised )
		{
			recFlg.ReceiveFinised = false;
			regex re("[ ,]");
			sregex_token_iterator first{ ReceiveBuffer.begin(), ReceiveBuffer.end(), re, -1 }, last;
			vector<std::string> SplitData{first, last};
			if( SplitData.size() != 3 )
			{
				SendMessage( ERROR, 7 );
			}
			else if( SplitData[ 0 ] == "set-led")
			{
				uint8_t led = stoi( SplitData[ 1 ] );
				uint16_t time = stoul( SplitData[ 2 ] );
				switch( led )
				{
					case 0:
						LED_1_ON( time );
						SendMessage( OK, 4 );
						break;
					case 1:
						LED_1_ON( time );
						SendMessage( OK, 4 );
						break;
					default:
						SendMessage( ERROR, 7 );
						break;
				}

			}
			else if( SplitData[ 0 ] == "echo")
			{
				uint8_t length = stoul( SplitData[ 1 ] );
				SendMessage( SplitData[ 2 ], length );
				SendMessage( OK, 4 );
			}
			else
			{
				SendMessage( ERROR, 7 );
			}
		}

		if( recFlg.led0off )
		{
			recFlg.led0off = false;
			SendMessage( "led-off: 0\r\n", 12 );
		}
		if( recFlg.led1off )
		{
			recFlg.led1off = false;
			SendMessage( "led-off: 1\r\n", 12 );
		}

	}
}
